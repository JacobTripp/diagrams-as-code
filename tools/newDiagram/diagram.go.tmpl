//
// Auto-generated; DO NOT EDIT
//
// rendered at: {{renderedAt}}
// yaml hash: {{yamlHash}}
// template hash: {{templateHash}}
//
package {{packageName .Diagram}}

import (
  "errors"
  "fmt"

	"github.com/JacobTripp/diagrams-as-code/graph"
)

type {{graphType .Diagram}} struct {
  *graph.Graph
}

func New() {{graphType .Diagram}} {
  _r := UseCase{graph.NewGraph("{{graphType .Diagram}}")}
  {{if ne .Diagram.Description ""}}
    _r.AddAttribute("description", "{{.Diagram.Description}}")
  {{end}}
  return _r
}

{{/* NODES */}}
{{range $node := .Nodes}}
func ({{recieverName (graphType $.Diagram)}} {{ graphType $.Diagram}}) Add{{getNodeName $node}}(name string) {
  {{recieverName (graphType $.Diagram)}}.AddPoint(new{{getNodeName $node}}(name))
}
func new{{getNodeName $node}}(name string) graph.Point {
  _{{getNodeName $node}} := graph.NewPoint(name)
  {{range $key, $val := .Attributes}}
    _{{getNodeName $node}}.AddAttribute("{{$key}}", "{{$val}}")
  {{end}}
  return _{{getNodeName $node}}
}
{{end}}

type node interface {
  GetAttributeValue(string) (any, error)
}

func typeString(n node) string {
  v, _ := n.GetAttributeValue("type")
  return v.(string)
}

type connectRule struct {
  from []string
  to []string
}

var ConnectionError = errors.New("invalid connection")

func connectionValidation(isFromNode bool, nodeType, lineType string) error {
  m := map[string]connectRule{
  {{range $edge := .Edges}}
    "{{.Name}}": connectRule{
    from: []string{ {{ range $edge.Disallow.From}}
      {{.}},
  {{end}}},
    to: []string{ {{ range $edge.Disallow.To}}
      {{.}},
  {{end}}},
    },
  {{end}}
  }
  
  var list []string
  if isFromNode {
    list = m[lineType].from
  } else {
    list = m[lineType].to
  }

  for _, v := range list {
    if v == nodeType {
      return ConnectionError
    }
  }

  return nil
}

{{/* EDGES */}}
{{range $edge := .Edges}}
var {{getEdgeName $edge}}Error = errors.New("invalid {{getEdgeName $edge}}")

func ({{recieverName (graphType $.Diagram)}} {{graphType $.Diagram}}) {{getEdgeName $edge}}(fromName, toName string) error {
foundTo, err := {{recieverName (graphType $.Diagram)}}.GetPoint(toName)
	if err == nil {
    err = connectionValidation(false, typeString(foundTo), "{{.Name}}")
	}
	if err != nil {
    return fmt.Errorf("%w: %s", {{getEdgeName $edge}}Error, err)
	}

  foundFrom, err := {{recieverName (graphType $.Diagram)}}.GetPoint(fromName)
	if err == nil {
    err = connectionValidation(true, typeString(foundFrom), "{{getEdgeName $edge}}")
	}
	if err != nil {
    return fmt.Errorf("%w: %s", {{getEdgeName $edge}}Error, err)
	}

  line := new{{getEdgeName $edge}}(foundFrom.Name + "{{getEdgeName $edge}}" + foundTo.Name)
	line.From = foundFrom
	line.To = foundTo
  {{recieverName (graphType $.Diagram)}}.AddLine(line)
	return nil
}

func new{{getEdgeName $edge}}(name string) graph.Line {
  _line := graph.NewLine(name)
  {{if ne .Description ""}}
    _line.AddAttribute("description", "{{$edge.Description}}")
  {{end}}
  {{range $name, $value := .Attributes}}
    _line.AddAttribute("{{$name}}", "{{$value}}")
  {{end}}
  return _line
}
{{end}}

var nodes = []string{
{{range $node := .Nodes}}
  "{{getNodeName $node}}",
{{end}}}

var edges = []string{
{{range $edge := .Edges}}
  "{{getEdgeName $edge}}",
{{end}}}

func ({{recieverName (graphType .Diagram)}} {{graphType .Diagram}}) ListNodes() []string {
  return nodes
}
func ({{recieverName (graphType .Diagram)}} {{graphType .Diagram}}) ListEdges() []string {
  return edges
}
